{"version":3,"file":"index-esm.min.js","sources":["../lib/PathLexeme.js","../lib/PathLexer.js","../lib/PathParser.js","../lib/SampleHandler.js"],"sourcesContent":["/**\n *  PathLexeme.js\n *\n *  @copyright 2002, 2013 Kevin Lindsey\n *  @module PathLexeme\n */\n\n/**\n *  PathLexeme\n */\nclass PathLexeme {\n    /**\n     *  @param {number} type\n     *  @param {string} text\n     */\n    constructor(type, text) {\n        this.type = type;\n        this.text = text;\n    }\n\n    /**\n     *  typeis\n     *\n     *  @param {number} type\n     *  @returns {boolean}\n     */\n    typeis(type) {\n        return this.type === type;\n    }\n}\n\n/*\n * token type enumerations\n */\nPathLexeme.UNDEFINED = 0;\nPathLexeme.COMMAND = 1;\nPathLexeme.NUMBER = 2;\nPathLexeme.EOD = 3;\n\nexport default PathLexeme;\n","/**\n *  PathLexer.js\n *\n *  @copyright 2003, 2013 Kevin Lindsey\n *  @module PathLexer\n */\n\nimport PathLexeme from \"./PathLexeme.js\";\n\n/**\n *  Create a new instance of PathLexer\n */\nclass PathLexer {\n    /**\n     *  @param {string} pathData\n     */\n    constructor(pathData) {\n        if (pathData === null || pathData === undefined) {\n            pathData = \"\";\n        }\n\n        this.setPathData(pathData);\n    }\n\n    /**\n     *  setPathData\n     *\n     *  @param {string} pathData\n     */\n    setPathData(pathData) {\n        if (typeof pathData !== \"string\") {\n            throw new Error(\"PathLexer.setPathData: The first parameter must be a string\");\n        }\n\n        this._pathData = pathData;\n    }\n\n    /**\n     *  getNextToken\n     */\n    getNextToken() {\n        let result = null;\n        let d = this._pathData;\n\n        while (result === null) {\n            if (d === null || d === \"\") {\n                result = new PathLexeme(PathLexeme.EOD, \"\");\n            }\n            else if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            // NOTE: Batik seemed to ignore the trailing /i in the following regex,\n            // so I expanded the regex to explicitly list both uppercase and\n            // lowercase commands.\n            else if (d.match(/^([AaCcHhLlMmQqSsTtVvZz])/)) {\n                result = new PathLexeme(PathLexeme.COMMAND, RegExp.$1);\n                d = d.substr(RegExp.$1.length);\n            }\n            /* eslint-disable-next-line unicorn/no-unsafe-regex */\n            else if (d.match(/^(([-+]?\\d+(\\.\\d*)?|[-+]?\\.\\d+)([eE][-+]?\\d+)?)/)) {\n                result = new PathLexeme(PathLexeme.NUMBER, parseFloat(RegExp.$1));\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                throw new Error(\"PathLexer.getNextToken: unrecognized path data \" + d);\n            }\n        }\n\n        this._pathData = d;\n\n        return result;\n    }\n}\n\nexport default PathLexer;\n","/**\n *  PathParser.js\n *\n *  @copyright 2003, 2017 Kevin Lindsey\n *  @module PathParser\n */\n\nimport PathLexer from \"./PathLexer.js\";\nimport PathLexeme from \"./PathLexeme.js\";\n\n\n/**\n *  PathParser\n */\nclass PathParser {\n    /**\n     * constructor\n     */\n    constructor() {\n        this._lexer = new PathLexer();\n        this._handler = null;\n    }\n\n    /**\n     *  parseData\n     *\n     *  @param {string} pathData\n     *  @throws {Error}\n     */\n    parseData(pathData) {\n        if (typeof pathData !== \"string\") {\n            throw new Error(\"PathParser.parseData: The first parameter must be a string\");\n        }\n\n        // begin parse\n        if (this._handler !== null && typeof this._handler.beginParse === \"function\") {\n            this._handler.beginParse();\n        }\n\n        // pass the pathData to the lexer\n        const lexer = this._lexer;\n\n        lexer.setPathData(pathData);\n\n        // set mode to signify new path\n        // NOTE: BOP means Beginning of Path\n        let mode = \"BOP\";\n\n        // Process all tokens\n        let token = lexer.getNextToken();\n\n        while (token.typeis(PathLexeme.EOD) === false) {\n            let parameterCount;\n            const params = [];\n\n            // process current token\n            switch (token.type) {\n                case PathLexeme.COMMAND:\n                    if (mode === \"BOP\" && token.text !== \"M\" && token.text !== \"m\") {\n                        throw new Error(\"PathParser.parseData: a path must begin with a moveto command\");\n                    }\n\n                    // Set new parsing mode\n                    mode = token.text;\n\n                    // Get count of numbers that must follow this command\n                    parameterCount = PathParser.PARAMCOUNT[token.text.toUpperCase()];\n\n                    // Advance past command token\n                    token = lexer.getNextToken();\n                    break;\n\n                case PathLexeme.NUMBER:\n                    // Most commands allow you to keep repeating parameters\n                    // without specifying the command again.  We just assume\n                    // that is the case and do nothing since the mode remains\n                    // the same and param_count is already set\n                    break;\n\n                default:\n                    throw new Error(\"PathParser.parseData: unrecognized token type: \" + token.type);\n            }\n\n            // Get parameters\n            for (let i = 0; i < parameterCount; i++) {\n                switch (token.type) {\n                    case PathLexeme.COMMAND:\n                        throw new Error(\"PathParser.parseData: parameter must be a number: \" + token.text);\n\n                    case PathLexeme.NUMBER:\n                        // convert current parameter to a float and add to\n                        // parameter list\n                        params[i] = parseFloat(token.text);\n                        break;\n\n                    default:\n                        throw new Error(\"PathParser.parseData: unrecognized token type: \" + token.type);\n                }\n\n                token = lexer.getNextToken();\n            }\n\n            // fire handler\n            if (this._handler !== null) {\n                const handler = this._handler;\n                const methodName = PathParser.METHODNAME[mode];\n\n                // convert types for arcs\n                if (mode === \"a\" || mode === \"A\") {\n                    params[3] = params[3] !== 0;\n                    params[4] = params[4] !== 0;\n                }\n\n                if (handler !== null && typeof handler[methodName] === \"function\") {\n                    handler[methodName](...params);\n                }\n            }\n\n            // Lineto's follow moveto when no command follows moveto params.  Go\n            // ahead and set the mode just in case no command follows the moveto\n            // command\n            switch (mode) {\n                case \"M\":\n                    mode = \"L\";\n                    break;\n                case \"m\":\n                    mode = \"l\";\n                    break;\n                default:\n                    // ignore for now\n            }\n        }\n\n        // end parse\n        if (this._handler !== null && typeof this._handler.endParse === \"function\") {\n            this._handler.endParse();\n        }\n    }\n\n    /**\n     *  setHandler\n     *\n     *  @param {Object} handler\n     */\n    setHandler(handler) {\n        this._handler = handler;\n    }\n}\n\n/*\n * class constants\n */\nPathParser.PARAMCOUNT = {\n    A: 7,\n    C: 6,\n    H: 1,\n    L: 2,\n    M: 2,\n    Q: 4,\n    S: 4,\n    T: 2,\n    V: 1,\n    Z: 0\n};\nPathParser.METHODNAME = {\n    A: \"arcAbs\",\n    a: \"arcRel\",\n    C: \"curvetoCubicAbs\",\n    c: \"curvetoCubicRel\",\n    H: \"linetoHorizontalAbs\",\n    h: \"linetoHorizontalRel\",\n    L: \"linetoAbs\",\n    l: \"linetoRel\",\n    M: \"movetoAbs\",\n    m: \"movetoRel\",\n    Q: \"curvetoQuadraticAbs\",\n    q: \"curvetoQuadraticRel\",\n    S: \"curvetoCubicSmoothAbs\",\n    s: \"curvetoCubicSmoothRel\",\n    T: \"curvetoQuadraticSmoothAbs\",\n    t: \"curvetoQuadraticSmoothRel\",\n    V: \"linetoVerticalAbs\",\n    v: \"linetoVerticalRel\",\n    Z: \"closePath\",\n    z: \"closePath\"\n};\n\nexport default PathParser;\n","/* eslint-disable prefer-rest-params, class-methods-use-this */\n/**\n *  SampleHandler.js\n *\n *  @copyright 2003, 2013 Kevin Lindsey\n *  @module SampleHandler\n */\n\n/**\n *  show\n *\n *  @param {string} name\n *  @param {Array<string>} params\n */\nfunction show(name, ...params) {\n    console.log(`${name}(${params.join(\",\")})`);\n}\n\n/**\n *  SampleHandler\n */\nclass SampleHandler {\n    /**\n     *  arcAbs - A\n     *\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {number} xAxisRotation\n     *  @param {boolean} largeArcFlag\n     *  @param {boolean} sweepFlag\n     *  @param {number} x\n     *  @param {number} y\n     */\n    arcAbs(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        show(\"arcAbs\", ...arguments);\n    }\n\n    /**\n     *  arcRel - a\n     *\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {number} xAxisRotation\n     *  @param {boolean} largeArcFlag\n     *  @param {boolean} sweepFlag\n     *  @param {number} x\n     *  @param {number} y\n     */\n    arcRel(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        show(\"arcRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicAbs - C\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicAbs(x1, y1, x2, y2, x, y) {\n        show(\"curvetoCubicAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicRel - c\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicRel(x1, y1, x2, y2, x, y) {\n        show(\"curvetoCubicRel\", ...arguments);\n    }\n\n    /**\n     *  linetoHorizontalAbs - H\n     *\n     *  @param {number} x\n     */\n    linetoHorizontalAbs(x) {\n        show(\"linetoHorizontalAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoHorizontalRel - h\n     *\n     *  @param {number} x\n     */\n    linetoHorizontalRel(x) {\n        show(\"linetoHorizontalRel\", ...arguments);\n    }\n\n    /**\n     *  linetoAbs - L\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    linetoAbs(x, y) {\n        show(\"linetoAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoRel - l\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    linetoRel(x, y) {\n        show(\"linetoRel\", ...arguments);\n    }\n\n    /**\n     *  movetoAbs - M\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    movetoAbs(x, y) {\n        show(\"movetoAbs\", ...arguments);\n    }\n\n    /**\n     *  movetoRel - m\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    movetoRel(x, y) {\n        show(\"movetoRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticAbs - Q\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticAbs(x1, y1, x, y) {\n        show(\"curvetoQuadraticAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticRel - q\n     *\n     *  @param {number} x1\n     *  @param {number} y1\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticRel(x1, y1, x, y) {\n        show(\"curvetoQuadraticRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicSmoothAbs - S\n     *\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicSmoothAbs(x2, y2, x, y) {\n        show(\"curvetoCubicSmoothAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoCubicSmoothRel - s\n     *\n     *  @param {number} x2\n     *  @param {number} y2\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoCubicSmoothRel(x2, y2, x, y) {\n        show(\"curvetoCubicSmoothRel\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticSmoothAbs - T\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticSmoothAbs(x, y) {\n        show(\"curvetoQuadraticSmoothAbs\", ...arguments);\n    }\n\n    /**\n     *  curvetoQuadraticSmoothRel - t\n     *\n     *  @param {number} x\n     *  @param {number} y\n     */\n    curvetoQuadraticSmoothRel(x, y) {\n        show(\"curvetoQuadraticSmoothRel\", ...arguments);\n    }\n\n    /**\n     *  linetoVerticalAbs - V\n     *\n     *  @param {number} y\n     */\n    linetoVerticalAbs(y) {\n        show(\"linetoVerticalAbs\", ...arguments);\n    }\n\n    /**\n     *  linetoVerticalRel - v\n     *\n     *  @param {number} y\n     */\n    linetoVerticalRel(y) {\n        show(\"linetoVerticalRel\", ...arguments);\n    }\n\n    /**\n     *  closePath - z or Z\n     */\n    closePath() {\n        show(\"closePath\", ...arguments);\n    }\n}\n\nexport default SampleHandler;\n"],"names":["PathLexeme","type","text","this","UNDEFINED","COMMAND","NUMBER","EOD","PathLexer","pathData","setPathData","Error","_pathData","result","d","match","substr","RegExp","$1","length","parseFloat","PathParser","_lexer","_handler","beginParse","lexer","mode","token","getNextToken","typeis","parameterCount","params","PARAMCOUNT","toUpperCase","i","handler","methodName","METHODNAME","endParse","show","name","console","log","join","A","C","H","L","M","Q","S","T","V","Z","a","c","h","l","m","q","s","t","v","z","SampleHandler","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","x","y","arguments","x1","y1","x2","y2"],"mappings":"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"}